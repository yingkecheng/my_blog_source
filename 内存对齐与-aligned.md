---
title: 内存对齐与 aligned
date: 2023-04-16 18:02:24
tags: [c 语言]
---

# 内存对齐

内存对齐指的是计算机在为结构体、联合体又或是基本数据类型分配内存空间时，按照一定规则使得数据类型所在的地址是它所占空间大小的整数倍。这个规则是由编译器决定的，不同编译器可能有不同的规则。对齐的目的是为了提高数据读取效率，因为计算机可以更快地访问对齐的内存地址。同时，对齐还可以保证不同编译器或不同平台下数据类型的一致性，防止出现因对齐方式不同导致的内存读取错误等问题。

在内存对齐的概念中，每个数据类型都有一个对齐值，也称为对齐系数或者对齐要求。对齐值指定了内存中该数据类型变量存储时的起始位置必须是对齐值的倍数。一般而言，对齐值是数据类型大小的整数倍。例如，在 32 位平台上，int 类型的对齐值通常是 4 个字节，double 类型的对齐值通常是8个字节。因此，在 32 位平台上，int 类型的变量只能分配在 0x00000004、0x00000008 等 4 字节倍数的地址上。这样的内存对齐规则可以提高系统性能，并且可以确保结构体中的每个成员可以被正确地读写。

内存对齐规则总结如下：

1. 结构体的起始存储位置必须是能够被结构体中最大的数据类型的对齐值所整除。

2. 每个数据成员存储的起始位置是自身对齐值的整数倍。

3. 结构体总大小（即 sizeof 的结果）必须是该结构体成员中最大的对齐值的整数倍。如果不满足，会自动填充空缺的字节。

4. 如果结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐值的整数倍地址开始存储。

5. 如果结构体包含数组成员，则数组成员的对齐方式和分别写对应元素类型的对齐值是一样的。

6. 如果结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐值的整数倍地址开始存储。

以下是一个例子，展示了一个结构体在内存中的分配情况：

```c
typedef struct {
    int a;
    char b;
    short c;
    char d;
} Foo;

int main(void) {
    printf("size of Foo: %d\n", sizeof(Foo));
    return 0;
}
```

以上代码在 STM32 平台上运行，输出结果为：

```shell
size of Foo: 12
```

`Foo` 的内存分配可以如下表示

```
| int a | char b | -- | short c | char d | -- -- -- |
```

其中 `--` 表示填充字节，用于满足对齐要求。

# aligned

`aligned` 是GCC、Clang等编译器提供的一个扩展属性，用于指定变量或结构体的对齐方式。其作用是使变量或结构体成员在内存中按照指定的对齐方式排布，从而提高内存访问的效率，避免由于内存对齐不当导致的性能问题和硬件异常。

具体地说，`aligned(n)` 用于指定对齐值，即变量在内存中所占字节数的倍数。需要注意的是，`aligned(n)` 的取值必须是2的整数次幂，并且不能小于变量本身的对齐值。如果指定的对齐值小于变量本身的对齐值，那么会以变量本身的对齐值为准；如果指定的对齐值大于变量本身的对齐值，那么会以指定的对齐值为准。此外，`aligned` 也可以用于结构体和联合体，指定它们的对齐方式，但需要注意的是，结构体或联合体的最大成员大小应该是其对齐值的整数倍，否则会在结构体或联合体末尾填充一些字节，以满足对齐要求。

例如

```c
typedef struct
{
    int b;
    char a;
    short c;
    char d;
} __attribute__((aligned(8))) Foo;
```

`__attribute__((aligned(8)))` 将 `Foo` 的对齐值设置为 8，故 `Foo` 的大小需要是 8 的整数倍，`Foo`的大小为 16 字节。
